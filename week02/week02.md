### SOLID란?

- **로버트 마틴**이 제시한 객체 지향 설계 5원칙
- **응집도 ↑, 결합도 ↓** → 확장성, 유지보수성, 재사용성 향상

---

### 1) SRP (Single Responsibility Principle) - 단일 책임 원칙

- 클래스는 **하나의 책임만** 가져야 한다.
- 책임이 여러 개면 변경 사유도 많아지고 응집도↓, 유지보수 어려워짐.

---

### 2) OCP (Open Closed Principle) - 개방 폐쇄 원칙

- **확장에는 열려(Open)** 있고, **변경에는 닫혀(Closed)** 있어야 한다.
- 기존 코드 수정 없이 새로운 기능 확장 가능해야 함.
- 예: 인터페이스/추상 클래스 사용 → 새로운 구현체 추가로 확장.

---

### 3) LSP (Liskov Substitution Principle) - 리스코프 치환 원칙

- **하위 클래스는 상위 클래스의 행위를 대체할 수 있어야 한다.**
- 부모의 규약을 깨뜨리지 않고, 일관된 동작을 보장해야 함.
- 잘못된 오버라이딩은 LSP 위반.

---

### 4) ISP (Interface Segregation Principle) - 인터페이스 분리 원칙

- **사용하지 않는 메서드에 의존하지 않아야 한다.**
- 큰 인터페이스 → 여러 개의 작은 인터페이스로 분리.

---

### 5) DIP (Dependency Inversion Principle) - 의존 역전 원칙

- **구현체(Concrete)보다 추상화(Interface/추상 클래스)에 의존**해야 한다.
- 변하기 쉬운 구체적인 것에 의존하면 변경에 취약.
- 스프링의 **DI(의존성 주입)**이 DIP를 구현한 대표 사례.

---
### DI란?

- **의존성(Dependency)**: 어떤 객체가 다른 객체를 사용할 때의 관계
- **의존성 주입(Dependency Injection)**: 객체가 사용할 **구체 클래스**를 직접 생성하지 않고, **외부에서 주입받는 방식**
- 즉, **객체 간의 의존 관계를 코드 내부가 아닌 외부에서 결정**하도록 하는 기법

---

### DI가 필요한 이유

- 코드에서 `new`를 직접 사용해 객체 생성 시, 특정 구현체에 강하게 의존 → **결합도 ↑**
- 구현체가 바뀌면 코드 수정 불가피 → 유지보수 어려움
- DI를 적용하면, **인터페이스 기반 설계** + **외부 주입** 덕분에 확장성과 테스트 용이성 ↑

---
### IoC란?

- **제어의 역전(Inversion of Control)**은 객체 생성, 의존 관계 관리, 실행 흐름 제어 권한을 개발자가 아닌 **프레임워크/컨테이너가 대신 관리**하는 개념.
- 즉, 프로그램의 흐름을 개발자가 직접 제어하지 않고, **외부에 제어권을 위임**하는 것.

---

### IoC가 필요한 이유

- 전통적인 방식: 객체 생성과 제어를 코드 내부에서 직접 수행 → 결합도 ↑
- IoC 적용: 객체 생성 및 제어를 외부(컨테이너)가 담당 → **결합도 ↓, 유연성 ↑**
- 유지보수, 테스트 용이

---

### IoC의 핵심 개념

- **제어권 역전**: 객체 생성과 생명주기를 개발자가 아닌 컨테이너가 관리
- **DI(Dependency Injection)**: IoC를 구현하는 방법 중 하나
- IoC → 개념, DI → 구현 방식 (즉, DI는 IoC의 한 형태)
---
### 생성자 주입

- 객체 생성 시점에 의존성 주입
- **불변성 보장**, 필수 의존성 주입 강제
- 테스트 용이, 순환 참조 조기 발견 가능
- **실무 권장 방식**

### 수정자 주입 (Setter)

- 객체 생성 후 Setter로 의존성 주입
- **선택적 의존성** 처리에 적합
- 의존성 변경 가능 → 안정성 낮음

### 필드 주입

- 어노테이션으로 필드에 직접 주입
- 코드 간단하지만 **테스트/유지보수 어려움**
- DI 컨테이너 필수 → 순수 Java 환경 불가
- **비권장**
---
### AOP란?

- **관점 지향 프로그래밍**
- 핵심 기능(Core Concern)과 부가 기능(Cross-Cutting Concern)을 분리하여 모듈화하는 기법
- 예: 로깅, 보안, 트랜잭션, 성능 모니터링 → 공통 관심사를 한 곳에 모아 관리

---

### AOP가 필요한 이유

- 중복 코드 제거
- 핵심 비즈니스 로직과 부가 기능을 분리 → 코드 가독성/유지보수성 ↑
- 변경 발생 시 한 곳만 수정하면 됨 → 확장성 ↑
---
### 서블릿이란?

- **Java 기반 웹 프로그래밍 기술**
- 클라이언트의 요청(HTTP 요청)을 받아 처리하고, 그 결과(HTTP 응답)를 반환하는 **서버 측 프로그램**
- **Servlet Container(예: Tomcat)** 위에서 동작

---

### 서블릿 동작 방식

1. 클라이언트가 웹 브라우저에서 요청 → HTTP Request 전달
2. 서블릿 컨테이너가 요청을 서블릿 객체에 전달
3. 서블릿이 요청 처리 (비즈니스 로직 실행)
4. 처리 결과를 HTTP Response로 응답

---

### 서블릿의 특징

- **Java 클래스**로 작성, `HttpServlet` 상속
- **멀티스레드 처리** → 동시에 여러 요청 처리 가능
- **라이프사이클 관리** (init → service → destroy)
- JSP, Spring MVC 등의 기반 기술